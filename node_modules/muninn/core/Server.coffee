#+--------------------------------------------------------------------+
#| Server.coffee
#+--------------------------------------------------------------------+
#| Copyright DarkOverlordOfData (c) 2014
#+--------------------------------------------------------------------+
#|
#| This file is a part of Muninn
#|
#| Muninn is free software; you can copy, modify, and distribute
#| it under the terms of the MIT License
#|
#+--------------------------------------------------------------------+
#
#	Connect driver
#
#   An adapter to the connect server instance
#   adds render support for views
#   registers all of our middleware in the right order
#   exposes an adapter registration point for sessions
#
fs        = require("fs")                 # File system
os        = require('os')                 # operating-system related utility functions
path      = require('path')               # path utils
http      = require('http')               # node server
cookie    = require('cookie')             # cookie parsing and serialization
sign      = require('cookie-signature')   # Sign and unsign cookies
dispatch  = require('dispatch')           # URL dispatcher for Connect
util      = require('../util')            # muninn utils
muninn    = require('../muninn')          # muninn core



class muninn.core.Server extends muninn.core.Async
  
  http: null
  #
  # @property [String] http driver: connect
  #
  driver: 'express'
  #
  # @property [Object] app
  #
  app: null
  #
  # @property [Integer] port
  #
  port: 0xd16a
  #
  # @property [String] ip local address
  #
  port: '127.0.0.1'
  #
  # @property [muninn.core.Config] configuration
  #
  config: null
  #
  # @property [RenderView] render lib
  #
  render: null
  #
  # @property [String] driver version
  #
  version: ''


  #
  # inner class Vars
  #
  class Vars

    #
    # Provides variables to a view
    #
    # @param  [Array] args  a list of hash to merge into this
    #
    constructor: ($args...) ->

      for $data in $args
        for $key, $val of $data
          @[$key] = $val

  constructor: () ->

    muninn.logMessage 'debug', "Server Class Initialized"

    @config = muninn.config
    $driver = require(@driver)
    @version = @driver+' v'+$driver.version
    @initialize($driver)


  #
  # Initialize the driver
  #
  # @param  [Object]  driver  http server object
  # @return [Void]
  #
  initialize:($driver) ->

    @app = $driver()
    @app.set 'port', @port = @config.item('http_port')
    @app.set 'ip', @ip = @config.item('http_ip')
    Render = muninn.loadClass('Render', 'core')
    $render = new Render()

    #
    # Template for initializing the server
    #
    @initializeLog $driver, $render
    @initializeAssets $driver, $render
    @initializeRequest $driver, $render
    @initializeResponse $driver, $render

  #
  # Set view helpers
  #
  # Sets the autoloaded helpers on the Variables class
  # prototype. This makes them global to all views.
  #
  # @param  [Object] helpers hash of helpers to add
  # @return [Object] the helpers hash
  #
  setHelpers: ($helpers) ->
    for $key, $val of $helpers
      Vars::[$key] = $val
    $helpers

  #
  # Careful with that axe, Eugene...
  #
  # @param [system.core.Router] router  the routing controller
  # @return [Void]
  #
  start: ($router, $ready) ->

    @http = http.createServer(@app)
    SocketIO = muninn.loadClass('SocketIO', 'core')
    new SocketIO(@)

    # Load routes and controllers
    for $name in @config.item('autoload').controllers
      Controller = muninn.loadClass($name, 'controllers')
      muninn.setRoutes Controller

    #
    # Register the exception handler
    #
    @app.use muninn.core.Exceptions.create().exceptionHandler()
    #
    # Register routes
    #
    @app.use dispatch(muninn.routes)
    @app.use ($err, $req, $res, $next) -> muninn.showError $err
    @app.use ($req, $res, $next) -> muninn.show404 $req.originalUrl

    #
    # Run all the tasks that queued up during
    # autoload and start the server running
    #
    @run ($err) =>

      muninn.logMessage 'debug', 'IP = %s', @ip
      muninn.logMessage 'debug', 'PORT = %s', @port

      @http.listen @port, @ip, =>
        muninn.logMessage 'info', "listening on port http://localhost:%d", @app.get('port')
        return
      return
    return


  #
  # Initialize the log
  #
  # @return [Void]
  #
  initializeLog: ($driver, $render) ->
    @app.use $driver.logger(@config.item('logger'))


  #
  # Initialize the assets
  #
  # @return [Void]
  #
  initializeAssets:($driver, $render) ->
    #
    # Expose asset folders
    #
    @app.use $driver.static(muninn.DOCPATH)
    #
    # Favorites icon
    #
    @app.use $driver.favicon(path.join(muninn.DOCPATH, @config.item('favicon')))

  #
  # Initialize the request
  #
  # @return [Void]
  #
  initializeRequest: ($driver, $render) ->
    #
    # Request parsing
    #
    @app.use $driver.query()
    @app.use $driver.bodyParser()
    @app.use $driver.methodOverride()


  #
  # Initialize the response
  #
  # @return [Void]
  #
  initializeResponse: ($driver, $render) ->
    #
    # response middleware
    #
    @app.use ($req, $res, $next) =>

      #
      # Represent
      #
      $res.setHeader 'X-Powered-By', "Muninn"
      #
      # Set the base url?
      #
      if @config.item('base_url') is ''
        $protocol = if $req.connection.encrypted then 'https' else 'http'
        @config.setItem 'base_url', $protocol+'://'+ $req.headers['host']

      #
      # Send JSON
      #
      # Send object as JSON
      #
      # @private
      # @param [Object] data  hash of variables to render with template
      # @return [Void]
      #
      $res.json = ($data = {}) ->
        $res.writeHead 200,
          'Content-Type'    : 'application/json; charset=utf-8'
        $res.end JSON.stringify($data)
        return

      #
      # Redirect
      #
      # Redirect to another url
      #
      # @private
      # @param [String] url url to redirect to
      # @param [String] type  location | refresh
      # @param [String] url url to redirect to
      # @return [Void]
      #
      $res.redirect = ($url, $type='location', $status = 302) ->

        switch $type
          when 'refresh'
            $res.writeHead $status,
              Refresh: 0
              url: $url
            $res.end null
          else
            $res.writeHead $status,
              Location: $url
            $res.end null



      #
      # Render the view
      #
      # Create a new Variable instance to merge the $data param
      # with the flashdata, as well as the config values and
      # helpers that have been added to the prototype
      #
      # @private
      # @param [String] view  path to view template
      # @param [Object] data  hash of variables to render with template
      # @param [Funcion] next optional async callback
      # @return [Void]
      #
      $res.render = ($view, $data = {}, $next) ->
        if typeof $data is 'function' then [$data, $next] = [{}, $data]

        # if it's not a filename, then directly render partial
        if Array.isArray($view)
          $html = $render.ect($view.join(''), new Vars($data))
          return $next(null, $html)

        if not fs.existsSync($view)
          return muninn.showError('Unable to load the requested file: %s', $view)
        #
        # Default terminal next
        #
        $next = $next ? ($err, $str) ->
          return $next($err) if $err
          $res.writeHead 200,
            'Content-Length'  : $str.length
            'Content-Type'    : 'text/html; charset=utf-8'
          $res.end $str
          return

        #
        # Read in the view file
        #
        fs.readFile $view, 'utf8', ($err, $str) ->
          return $next($err) if $err
          $ext = path.extname($view).replace('.','')

          if $render[$ext]?

            try
              $next(null, $render[$ext]($str, new Vars($data, filename: $view, flashdata: $res.flashdata)))

            catch $err
              muninn.showError $err

          else muninn.showError 'Invalid view file type: %s (%s)', $ext, $view

      $next()



