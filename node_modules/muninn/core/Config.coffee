#+--------------------------------------------------------------------+
#  Config.coffee
#+--------------------------------------------------------------------+
#  Copyright DarkOverlordOfData (c) 2012 - 2014
#+--------------------------------------------------------------------+
#
#  This file is a part of Muninn
#
#  Muninn is free software you can copy, modify, and distribute
#  it under the terms of the MIT License
#
#+--------------------------------------------------------------------+

#
# Exspresso Config Class
#
# This class contains functions that enable config files to be managed
#
#
fs = require('fs')
path = require('path')
muninn  = require('../muninn')


class muninn.core.Config

  #
  # @static property [muninn.core.Config] singleton config object
  #
  @config = null

  #
  # Create the config object singleton
  #
  # @return	[muninn.core.Config]  the config object
  #
  @create = () ->
    Config.config = Config.config ? new Config()


  #
  # @property [Object] array list of paths to load config files at
  #
  paths: null
  #
  # @property [Object] config data loaded from files
  #
  config: null
  #
  # @property [Object] module environment
  #
  modules: null

  #
  # Constructor
  #
  # Sets the config data from the primary config.coffee file as a class variable
  #
  #
  constructor: () ->

    muninn.logMessage 'debug', "Config Class Initialized"

    # Get the core config array, and bind the environment values
    $config = Object.create(muninn.getConfig(),
      classpaths: value:
        system            : muninn.SYSPATH
        application       : muninn.APPPATH
        modules           : muninn.MODPATH
      module_paths: value: [
        muninn.MODPATH
        muninn.APPPATH+'modules/'
      ]
      model_paths: value: [
        muninn.APPPATH
      ]
      view_paths: value: [
        muninn.APPPATH
      ]
      controller_paths: value: [
        muninn.APPPATH
        muninn.SYSPATH
      ]
    )

    Object.defineProperties @,
      paths         : {enumerable: true,  writeable: false, value: [muninn.APPPATH]}
      modpaths      : {enumerable: true,  writeable: false, value: []}
      modules       : {enumerable: true,  writeable: false, value: {}}
      config        : {enumerable: true,  writeable: false, value: $config}

  #
  # Fetch a config file item
  #
  #
  # @param  [String]  item the config item name
  # @param  [String]  index the index name
  # @return	[String]  the config item, empty string if not found
  #
  item: ($item, $index = '') ->
    if $index is ''
      return '' unless @config[$item]?
      @config[$item]

    else
      return '' unless @config[$index]?
      return '' unless @config[$index][$item]?
      @config[$index][$item]

  #
  # Set a config file item
  #
  # @param  [String]  item the config item key
  # @param  [String]  value the config item value
  # @return [Void]
  #
  setItem: ($item, $value) ->
    if 'string' is typeof $item then @config[$item] = $value
    else @setItem($key, $val) for $key, $val of $item
    return
  #
  # Get Paths
  #
  # @param  [String]  hint  the module to search first
  # @param  [Array<String>] packages  array of app locations to search next
  # @return [Array<String>] the combined list
  #
  getPaths: ($hint = '', $packages = @paths) ->
    return @modpaths.concat($packages) if $hint is ''
    #
    # Search the specified $module first
    #
    if @modules[$hint]?
      $paths = [@modules[$hint].path+'/']
      for $name, $module of @modules
        $paths.push $module.path+'/' unless $name is $hint
      $paths.concat($packages)

  #
  # Add Path
  #
  # Adds a module path to the loader paths
  #
  # @param  [String]  path  the path to add
  # @return [Void]
  #
  addPath: ($path) ->

    $path = path.join($path, '/')
    @paths.unshift $path if @paths.indexOf($path) is -1
    return

