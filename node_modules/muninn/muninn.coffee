#+--------------------------------------------------------------------+
#| muninn.coffee
#+--------------------------------------------------------------------+
#| Copyright DarkOverlordOfData (c) 2014
#+--------------------------------------------------------------------+
#|
#| This file is a part of Muninn
#|
#| Muninn is free software; you can copy, modify, and distribute
#| it under the terms of the MIT License
#|
#+--------------------------------------------------------------------+
#
# muninn framework
#

fs = require('fs')
path = require('path')
format = require('util').format

class muninn

  #
  # local static variables
  #
  _classpaths       = {}    # namespace roots
  _classes          = {}    # singleton class cache
  _is_loaded        = {}    # singleton class loaded flag
  _class            = {}    # class metadata cache
  __PROTO__         = true  # if true, set mixin using the '__proto__' property


  #
  # privately dereference some methods
  #
  create                    = Object.create
  defineProperties          = Object.defineProperties
  defineProperty            = Object.defineProperty
  freeze                    = Object.freeze
  getOwnPropertyDescriptor  = Object.getOwnPropertyDescriptor
  getOwnPropertyNames       = Object.getOwnPropertyNames
  getPrototypeOf            = Object.getPrototypeOf
  keys                      = Object.keys
  prototype                 = Object.prototype

  #
  # set the environment
  #
  @ENVIRONMENT = process.env.ENVIRONMENT ? process.env.NODE_ENV ? 'development'

  #
  #  The coffee-script file extension
  #
  @EXT = '.coffee'

  #
  #  Path to the system folder
  #
  @SYSPATH = __dirname

  #
  # The path to the application folder
  #
  @APPPATH = path.join(__dirname, 'app/')

  #
  # The path to the static assets folder
  #
  @DOCPATH = path.join(__dirname, 'www/')

  #
  # The path to the modules folder
  #
  @MODPATH = ''

  #
  # muninn.core.Log object
  #
  @log = null

  #
  # muninn.core.Config object
  #
  @config = null

  #
  # Routes hash
  #
  @routes = {}

  #
  # private config hash
  #
  config = null

  #
  # Init
  #
  # Initialize the framework
  #
  # @param [String] root of the embedding app
  # @param [String] application folder
  # @param [String] static asset folder
  # @param [String] modules folder
  # @return [None]
  #
  @init = ($root = __dirname, $app = 'app', $www = 'www', $mod = '') ->

    muninn.APPPATH = path.join($root, $app, '/')
    muninn.DOCPATH = path.join($root, $www, '/')
    muninn.MODPATH = if $mod is '' then '' else path.join($root, $mod, '/')

    muninn.config = muninn.core.Config.create()

  #
  # Is Dir?
  #
  # Is the path a directory
  #
  # @param [String] path
  # @return [Boolean] true
  #
  @isDir = ($path) ->
    fs.existsSync($path) and fs.statSync($path).isDirectory()

  #
  # Loads the main config.coffee file
  #
  # This function lets us grab the config file even if the Config class
  # hasn't been instantiated yet
  #
  # @param  [Object]  replace hash of replacement key/value pairs
  # @return [Object] the config hash
  #
  @getConfig = ($replace = {}) ->

    return config if config?

    #  Fetch the config file
    $found = false
    config = {}

    # merge together config, overlaying with environment specific values
    $check_locations = [muninn.APPPATH, path.join(muninn.APPPATH, muninn.ENVIRONMENT)]

    for $location in $check_locations

      $file_path = path.join($location, 'config')
      if fs.existsSync($file_path)
        $found = true
        config[$key] = $val for $key, $val of require($file_path)

    if not $found
      console.log 'The configuration file does not exist.'
      process.exit

    #  Does the $config array exist in the file?
    if not config?
      console.log 'Your config file does not appear to be formatted correctly.'
      process.exit

    #  Are any values being dynamically replaced?
    config[$key] = $val for $key, $val of $replace when config[$key]?

    config

  #
  # Returns the specified config item
  #
  # @param  [String]  item  the config value name
  # @return [Mixed] the config item value
  #
  @configItem = ($item) ->

    muninn.getConfig() if not config?
    config[$item] || ''

  #
  # Load Class
  #
  # @param  [String]  class name
  # @param  [String]  library folder
  # @param  [String]  prefix
  # @return [Mixed] the class object
  #
  @loadClass = ($class, $folder = 'lib', $prefix = '') ->

    for location in [muninn.APPPATH, muninn.SYSPATH]
      if fs.existsSync("#{location}/#{$folder}/#{$class}#{muninn.EXT}")
        return require("#{location}/#{$folder}/#{$class}#{muninn.EXT}")

    muninn.logMessage 'error', 'Unable to load class %s', $class

  #
  # Set Routes
  #
  # @param  [Class]  Controller class
  # @return [Void] none
  #
  @setRoutes = (Controller) ->
    for $route, $method of Controller.routes
      # Wrap each route in a closure
      do ($route, $method) ->
        muninn.routes[$route] = ($req, $res, $next, $args...) ->
          (new Controller($req, $res, $next))[$method]($args...)
    return

  #
  # Error Handler
  #
  # This function lets us invoke the exception class and
  # display errors using the standard error template located
  # in application/errors/5xx.eco
  # This function will send the error page directly to the
  # browser and exit.
  #
  # @param  [Array] args  the argment array
  # @return [Boolean] true
  #
  @showError = ($args...) ->
    return false unless $args[0]?

    Exceptions = muninn.core.Exceptions.create()
    if typeof $args[0] is 'string'
      Exceptions.show5xx format.apply(undefined, $args), '5xx', 500
    else
      Exceptions.show5xx $args[0], '5xx', 500

  #
  # 404 Page Handler
  #
  # This function is similar to the show_error() function above
  # However, instead of the standard error template it displays
  # 404 errors.
  #
  # @param  [Array] args  the argment array
  # @param  [Boolean] log_error write to log
  # @return [Boolean] true
  #
  @show404 = ($page = '', $log_error = true) ->
    Exceptions = muninn.core.Exceptions.create()
    Exceptions.show404 $page, $log_error

  #
  # Error Logging Interface
  #
  # We use this as a simple mechanism to access the logging
  # class and send messages to be logged.
  #
  # @param [String] level the logging level: error | debug | info
  # @param [Array]  args  the remaining args match the sprintf signature
  # @return [Boolean] true
  #
  @logMessage = ($level = 'error', $args...) ->
    return true if muninn.configItem('log_threshold') is 0
    muninn.log = log = log ? new muninn.core.Log()
    log.write $level, format.apply(undefined, $args)

#  @showError = ($args...) ->
#    muninn.logMessage 'error', $args...
#    process.exit()
  #
  # Magic
  #
  # Dependency injection via prototype.
  #
  # Args can be
  #
  #
  #   1)  A list of classes followed by an optional list
  #       of constructor parameters.
  #
  #       This is used to create a super-controller, where
  #       the controller's properties and methods are available
  #       to all objects loaded by the controller.
  #
  #
  #   2)  A list of objects to use as prototypes.
  #
  #       This is used to merge the super-controller with data
  #       making the controller's properties and methods
  #       available to the view.
  #
  #
  #
  # @param  [Object]  proto  the prototype of the new object
  # @param  [Array] args  list of mixin classes, followed by construcor args
  # @return [Object] the fabricated mixin
  #
  @magic = ($proto, $args...) ->

    $properties = {}
    $pos = 0

    # get the mixin class(es)
    while 'function' is typeof ($mixin = $args[$pos])
      # the 1st mixin class will also be the constructor
      $class = $mixin if $pos is 0
      $pos++
      for $key, $val of metadata($mixin)
        $properties[$key] = $val

    # no class was encountered
    if not $class? then switch $args.length
      when 0
      # simple case -
        return create($proto)

      when 1
      # optimized case -
        if __PROTO__
          # array inherits from the object
          $args[0].__proto__ = $proto
          return create($args[0])

        else
          for $key in getOwnPropertyNames($args[0])
            $properties[$key] = getOwnPropertyDescriptor($args[0], $key)

      else
      # multiple arrays -
        if __PROTO__
          # each array inherits from the next
          for $i in [0...$args.length]
            $args[$i].__proto__ = $args[$i+1]
          # last array inherits from the object
          $args[$args.length-1].__proto__ = $proto
          return create($args[0])

        else
          for $data in $args
            for $key in getOwnPropertyNames($data)
              $properties[$key] = getOwnPropertyDescriptor($data, $key)

    # clone the object with all properties
    $this = create($proto, $properties)
    # call the constructor
    $class.apply $this, $args[$pos..] if $class?
    $this

  #
  # Get Class Metadata
  #
  # Analyze the metadata for a class, then build and cache
  # a table of property definitions for that classs.
  #
  # @param  [Object]  class a class constructor function
  # @return [Object]  the cached metadata
  #
  metadata = ($class) ->

    $name = $class::constructor.name
    if not _class[$name]?

      $props = {}       # an array to build the object property def
      $chain = []       # an array to list the inheritance chain
      $proto = $class:: # starting point in the chain

      # Build an inheritance list
      until $proto is prototype
        $chain.push $proto
        $proto = getPrototypeOf($proto)

      # Reverse list to process overrides in the correct order
      for $proto in $chain.reverse()
        if $proto isnt Object::
          # Build the inherited properties table
          for $key in getOwnPropertyNames($proto)
            $props[$key] = getOwnPropertyDescriptor($proto, $key)

      # cache the class definition
      _class[$name] = $props
    _class[$name]



  #
  # Set Classpath
  #
  #   Adds a namespace/classpath pair
  #   The namespace root is associated with the path.
  #   load_class will build the namespace tree from
  #   the file system and load the class into the correct
  #   branch of the tree
  #
  #
  # @param  [Object]    array of {namespace: classpath}
  # @return [Void]
  #
  @set_classpath = ($def) ->
    _classpaths[$namespace] = $classpath for $namespace, $classpath of $def



  #
  # Core namespace
  #
  class @core

  #
  # DB namespace
  #
  class @db

  #
  # Lib namespace
  #
  class @lib


module.exports = muninn

# load the framework core classes
require './core/Async'
require './core/Benchmark'
require './core/Config'
require './core/Controller'
require './core/Exceptions'
require './core/Loader'
require './core/Log'
require './core/Render'
require './core/Server'
require './core/SocketIO'


