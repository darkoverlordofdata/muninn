#+--------------------------------------------------------------------+
#| muninn.coffee
#+--------------------------------------------------------------------+
#| Copyright DarkOverlordOfData (c) 2014
#+--------------------------------------------------------------------+
#|
#| This file is a part of Muninn
#|
#| Muninn is free software; you can copy, modify, and distribute
#| it under the terms of the MIT License
#|
#+--------------------------------------------------------------------+
#
# muninn framework
#

fs = require('fs')
path = require('path')
format = require('util').format

class muninn

  #
  # set the environment
  #
  @ENVIRONMENT = process.env.ENVIRONMENT ? process.env.NODE_ENV ? 'development'

  #
  #  The coffee-script file extension
  #
  @EXT = '.coffee'

  #
  #  Path to the system folder
  #
  @SYSPATH = __dirname

  #
  # The path to the application folder
  #
  @APPPATH = path.join(__dirname, 'app')

  #
  # The path to the static assets folder
  #
  @DOCPATH = path.join(__dirname, 'www')

  #
  # The path to the modules folder
  #
  @MODPATH = ''

  #
  # muninn.core.Log object
  #
  @log = null

  #
  # muninn.core.Config object
  #
  @config = null

  #
  # Routes hash
  #
  @routes = {}

  #
  # private config hash
  #
  config = null

  #
  # Init
  #
  # Initialize the framework
  #
  # @param [String] root of the embedding app
  # @param [String] application folder
  # @param [String] static asset folder
  # @param [String] modules folder
  # @return [None]
  #
  @init = ($root = __dirname, $app = 'app', $www = 'www', $mod = '') ->
    muninn.APPPATH = path.join($root, $app)
    muninn.DOCPATH = path.join($root, $www)
    muninn.MODPATH = if $mod is '' then '' else path.join($root, $mod)

    muninn.config = muninn.core.Config.create()

  #
  # Is Dir?
  #
  # Is the path a directory
  #
  # @param [String] path
  # @return [Boolean] true
  #
  @isDir = ($path) ->
    fs.existsSync($path) and fs.statSync($path).isDirectory()

  #
  # Loads the main config.coffee file
  #
  # This function lets us grab the config file even if the Config class
  # hasn't been instantiated yet
  #
  # @param  [Object]  replace hash of replacement key/value pairs
  # @return [Object] the config hash
  #
  @getConfig = ($replace = {}) ->

    return config if config?

    #  Fetch the config file
    $found = false
    config = {}

    # merge together config, overlaying with environment specific values
    $check_locations = [muninn.APPPATH, path.join(muninn.APPPATH, muninn.ENVIRONMENT)]

    for $location in $check_locations

      $file_path = path.join($location, 'config')
      if fs.existsSync($file_path)
        $found = true
        config[$key] = $val for $key, $val of require($file_path)

    if not $found
      console.log 'The configuration file does not exist.'
      process.exit

    #  Does the $config array exist in the file?
    if not config?
      console.log 'Your config file does not appear to be formatted correctly.'
      process.exit

    #  Are any values being dynamically replaced?
    config[$key] = $val for $key, $val of $replace when config[$key]?

    config

  #
  # Returns the specified config item
  #
  # @param  [String]  item  the config value name
  # @return [Mixed] the config item value
  #
  @configItem = ($item) ->

    muninn.getConfig() if not config?
    config[$item] || ''

  #
  # Load Class
  #
  # @param  [String]  class name
  # @param  [String]  library folder
  # @param  [String]  prefix
  # @return [Mixed] the class object
  #
  @loadClass = ($class, $folder = 'lib', $prefix = '') ->

    for location in [muninn.APPPATH, muninn.SYSPATH]
      if fs.existsSync("#{location}/#{$folder}/#{$class}#{muninn.EXT}")
        return require("#{location}/#{$folder}/#{$class}#{muninn.EXT}")

    muninn.logMessage 'error', 'Unable to load class %s', $class

  @setRoutes = ($routes) ->
    for $key, $value of $routes
      muninn.routes[$key] = $value
  #
  # Error Logging Interface
  #
  # We use this as a simple mechanism to access the logging
  # class and send messages to be logged.
  #
  # @param [String] level the logging level: error | debug | info
  # @param [Array]  args  the remaining args match the sprintf signature
  # @return [Boolean] true
  #
  @logMessage = ($level = 'error', $args...) ->
    return true if muninn.configItem('log_threshold') is 0
    muninn.log = log = log ? new muninn.core.Log()
    log.write $level, format.apply(undefined, $args)

  #
  # Core namespace
  #
  class @core

  #
  # DB namespace
  #
  class @db

  #
  # Lib namespace
  #
  class @lib


module.exports = muninn

# load the framework classes
require './core/Benchmark'
require './core/Config'
require './core/Controller'
require './core/Log'
require './core/Server'
require './lib/SocketIO'

